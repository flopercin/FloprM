<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>3D Platform</title>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        #joystick {
            position: fixed;
            bottom: 50px;
            left: 50px;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            z-index: 100;
        }
        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 30px;
            left: 30px;
        }
        #fullscreenBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="joystick"><div id="joystickKnob"></div></div>
    <button id="fullscreenBtn">Fullscreen</button>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script>
        let scene, camera, renderer, controls, platform, joystickActive = false, joystickVector = { x: 0, y: 0 };
        const moveSpeed = 0.1, objects = [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6;
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            controls = new THREE.PointerLockControls(camera, document.body);
            
            const light = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(light);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 0);
            scene.add(directionalLight);
            
            createPlatform();
            createWalls();
            
            document.addEventListener('click', () => {
                if (!controls.isLocked) {
                    controls.lock();
                }
            });
            
            controls.addEventListener('lock', () => {
                document.getElementById('joystick').style.display = 'none';
            });
            
            controls.addEventListener('unlock', () => {
                document.getElementById('joystick').style.display = 'block';
            });
            
            setupJoystick();
            setupFullscreenButton();
            window.addEventListener('resize', onWindowResize);
            animate();
        }
        
        function createPlatform() {
            const geometry = new THREE.PlaneGeometry(100, 100);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            platform = new THREE.Mesh(geometry, material);
            platform.rotation.x = -Math.PI / 2;
            scene.add(platform);
        }
        
        function createWalls() {
            const wallGeometry = new THREE.BoxGeometry(100, 10, 1);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
            
            const wall1 = new THREE.Mesh(wallGeometry, wallMaterial);
            wall1.position.set(0, 5, -50);
            scene.add(wall1);
            objects.push(wall1);
            
            const wall2 = new THREE.Mesh(wallGeometry, wallMaterial);
            wall2.position.set(0, 5, 50);
            wall2.rotation.y = Math.PI;
            scene.add(wall2);
            objects.push(wall2);
            
            const wall3 = new THREE.Mesh(wallGeometry, wallMaterial);
            wall3.position.set(-50, 5, 0);
            wall3.rotation.y = Math.PI / 2;
            scene.add(wall3);
            objects.push(wall3);
            
            const wall4 = new THREE.Mesh(wallGeometry, wallMaterial);
            wall4.position.set(50, 5, 0);
            wall4.rotation.y = -Math.PI / 2;
            scene.add(wall4);
            objects.push(wall4);
        }
        
        function setupJoystick() {
            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('joystickKnob');
            const joystickSize = joystick.offsetWidth;
            const knobSize = knob.offsetWidth;
            const maxDist = (joystickSize - knobSize) / 2;
            
            let touchId = null;
            
            joystick.addEventListener('touchstart', (e) => {
                if (touchId === null) {
                    touchId = e.changedTouches[0].identifier;
                    joystickActive = true;
                }
            });
            
            joystick.addEventListener('touchmove', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        const touch = e.changedTouches[i];
                        const rect = joystick.getBoundingClientRect();
                        const centerX = rect.left + joystickSize / 2;
                        const centerY = rect.top + joystickSize / 2;
                        
                        let dx = touch.clientX - centerX;
                        let dy = touch.clientY - centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > maxDist) {
                            dx = dx * maxDist / distance;
                            dy = dy * maxDist / distance;
                        }
                        
                        knob.style.transform = `translate(${dx}px, ${dy}px)`;
                        joystickVector.x = dx / maxDist;
                        joystickVector.y = -dy / maxDist;
                        break;
                    }
                }
            });
            
            joystick.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        knob.style.transform = 'translate(30px, 30px)';
                        joystickVector.x = 0;
                        joystickVector.y = 0;
                        joystickActive = false;
                        touchId = null;
                        break;
                    }
                }
            });
        }
        
        function setupFullscreenButton() {
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable fullscreen: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function handleMovement() {
            if (controls.isLocked) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                const sideDirection = new THREE.Vector3();
                camera.getWorldDirection(sideDirection);
                sideDirection.y = 0;
                sideDirection.cross(camera.up);
                sideDirection.normalize();
                
                if (joystickActive) {
                    controls.moveRight(sideDirection.x * joystickVector.x * moveSpeed * 2 + direction.x * joystickVector.y * moveSpeed * 2);
                    controls.moveForward(sideDirection.z * joystickVector.x * moveSpeed * 2 + direction.z * joystickVector.y * moveSpeed * 2);
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            handleMovement();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>